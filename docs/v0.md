# v0 — Protocol Specification

v0 is the bootstrap protocol. It is the only version designed by hand — everything after is proposed and ratified by the network through v0's own mechanisms.

## Table of Contents

1. [Identity](#1-identity)
2. [Message Format](#2-message-format)
3. [Transport](#3-transport)
4. [Peer Discovery](#4-peer-discovery)
5. [Gossip](#5-gossip)
6. [Proposals](#6-proposals)
7. [Votes](#7-votes)
8. [Reputation](#8-reputation)
9. [Sybil Resistance](#9-sybil-resistance)
10. [Partition Detection](#10-partition-detection)
11. [Protocol Evolution](#11-protocol-evolution)

---

## 1. Identity

A node is an Ed25519 keypair.

- **Private key:** 32 bytes, Ed25519. Never transmitted.
- **Public key:** 32 bytes, Ed25519. Serves as the node's identity.
- **Node ID:** The hex-encoded public key. This is the canonical identifier.

All messages are signed by the sender's private key. All signatures are verified against the sender's public key.

### Key Operations

| Operation | Algorithm | Input | Output |
|---|---|---|---|
| Sign | Ed25519 | message bytes + private key | 64-byte signature |
| Verify | Ed25519 | message bytes + signature + public key | boolean |

### DID Representation (Optional)

Nodes MAY represent their identity as a DID for interoperability:

```
did:valence:<hex-encoded-public-key>
```

The protocol does not require DIDs — the raw public key is sufficient. DIDs are a convenience for systems that use them.

---

## 2. Message Format

Every message is a signed JSON envelope.

### Wire Format

**Stream protocols (point-to-point):** Length-prefixed JSON.

```
+-------------------+-----------------------------+
| 4 bytes (BE u32)  |  JSON payload (UTF-8)       |
| = payload length  |                             |
+-------------------+-----------------------------+
```

Maximum payload size: 8 MiB. Messages exceeding this MUST be rejected.

**GossipSub (broadcast):** Plain UTF-8 JSON. GossipSub handles message boundaries.

### Envelope Schema

```json
{
  "version": 0,
  "type": "<message_type>",
  "id": "<sha256_hex_of_payload>",
  "from": "<hex_public_key>",
  "timestamp": <unix_milliseconds>,
  "payload": { ... },
  "signature": "<hex_ed25519_signature>"
}
```

| Field | Type | Description |
|---|---|---|
| `version` | integer | Protocol version. MUST be `0` for this spec. |
| `type` | string | Message type (see §6, §7, §4). |
| `id` | string | SHA-256 hex digest of the canonical payload bytes. Content address. |
| `from` | string | Hex-encoded Ed25519 public key of the sender. |
| `timestamp` | integer | Unix time in milliseconds when the message was created. |
| `payload` | object | Type-specific payload (see below). |
| `signature` | string | Hex-encoded Ed25519 signature over the **signing body**. |

### Signing Body

The signature covers the canonical JSON encoding of:

```json
{
  "version": <version>,
  "type": "<type>",
  "id": "<id>",
  "from": "<from>",
  "timestamp": <timestamp>,
  "payload": <payload>
}
```

Canonical encoding: keys sorted alphabetically, no whitespace (`separators=(',', ':')`), UTF-8.

### Content Addressing

The `id` field is the SHA-256 hex digest of the canonical payload JSON bytes (same encoding rules as signing body, but only the `payload` object). Messages are deduplicated by `id` — a node MUST NOT re-propagate a message it has already seen.

---

## 3. Transport

v0 uses libp2p as the transport layer.

### Stream Protocols (Point-to-Point)

| Protocol ID | Purpose |
|---|---|
| `/valence/sync/1.0.0` | Pull-based synchronization (request/response) |
| `/valence/auth/1.0.0` | DID-based authentication handshake |
| `/valence/trust/1.0.0` | Trust attestation exchange |

### GossipSub Topics (Broadcast)

| Topic | Purpose |
|---|---|
| `/valence/proposals` | New proposals, edits, state changes |
| `/valence/votes` | Vote broadcasts |
| `/valence/peers` | Peer discovery announcements |

### NAT Traversal

Nodes SHOULD support libp2p circuit relay v2 for NAT traversal. Nodes with public addresses SHOULD act as relay nodes.

### Connection Security

All connections use libp2p's Noise protocol for encryption and authentication. The Ed25519 identity key is used for the Noise handshake, binding the transport layer identity to the protocol layer identity.

---

## 4. Peer Discovery

### Bootstrap

A new node starts with at least one known peer address (a bootstrap node). Bootstrap nodes are not special — they are regular nodes that happen to be well-known.

A list of default bootstrap nodes SHOULD be included in reference implementations. Nodes MAY configure additional or alternative bootstrap nodes.

### Peer Exchange

Nodes announce themselves on the `/valence/peers` GossipSub topic:

```json
{
  "type": "PEER_ANNOUNCE",
  "payload": {
    "addresses": ["<multiaddr>", ...],
    "capabilities": ["propose", "vote", "store"],
    "version": 0,
    "uptime_seconds": <integer>
  }
}
```

Nodes SHOULD announce periodically (suggested: every 5 minutes). Nodes SHOULD maintain a local peer table and prune peers that haven't announced in 30 minutes.

### Anti-Fragmentation

Nodes MUST periodically connect to random peers outside their immediate neighborhood. Suggested: every 10 minutes, pick a random peer from the full peer table (not just directly connected peers) and sync.

This prevents the network from clustering into disconnected subgraphs.

---

## 5. Gossip

### Push

When a node creates or receives a new message (proposal, vote, peer announcement), it publishes to the appropriate GossipSub topic. GossipSub handles fan-out to mesh peers.

### Pull (Sync)

Nodes periodically request missed messages from peers via the `/valence/sync/1.0.0` stream protocol:

**Sync Request:**

```json
{
  "type": "SYNC_REQUEST",
  "payload": {
    "since": <unix_milliseconds>,
    "types": ["PROPOSE", "VOTE"],
    "limit": 100
  }
}
```

**Sync Response:**

```json
{
  "type": "SYNC_RESPONSE",
  "payload": {
    "messages": [ ... ],
    "has_more": true,
    "checkpoint": "<merkle_root_hex>"
  }
}
```

### Deduplication

Nodes maintain a set of seen message IDs (content hashes). A message MUST NOT be re-propagated if its `id` has already been seen. Implementations SHOULD use a bounded cache (suggested: 100,000 entries, LRU eviction).

---

## 6. Proposals

### Message Types

#### REQUEST

A broadcast need. "I need something."

```json
{
  "type": "REQUEST",
  "payload": {
    "title": "<string>",
    "body": "<string — markdown>",
    "tags": ["<string>", ...]
  }
}
```

#### PROPOSE

A proposed solution. May reference a request, or stand alone.

```json
{
  "type": "PROPOSE",
  "payload": {
    "title": "<string>",
    "body": "<string — markdown description>",
    "content_hash": "<sha256_hex>",
    "content_type": "<mime_type>",
    "content_size": <bytes>,
    "content_url": "<optional — where to fetch the artifact>",
    "request_id": "<message_id | null>",
    "claims": [
      {
        "statement": "<human-readable claim>",
        "verifiable": <boolean>,
        "evidence": "<optional — URL or description>"
      }
    ],
    "eol": <unix_milliseconds | null>
  }
}
```

**Content delivery:** Small artifacts (< 1 MiB) MAY be inlined as base64 in an optional `content_inline` field. Larger artifacts are referenced by `content_hash` and fetched out-of-band via `content_url` or from peers who have it. The hash ensures integrity regardless of source.

**Claims:** Optional verifiable assertions about what the proposal does. Claims are signal — other nodes can verify them and report results, building confidence (or doubt) in the proposal.

**EOL:** Only used for protocol change proposals. Specifies when the previous protocol version dies.

#### EDIT

A proposed modification to an existing proposal.

```json
{
  "type": "EDIT",
  "payload": {
    "proposal_id": "<message_id of the original PROPOSE>",
    "title": "<optional — new title>",
    "body": "<string — description of the edit>",
    "patch": "<unified diff or replacement content_hash>",
    "claims": [ ... ]
  }
}
```

Edits are themselves subject to voting. The original proposal author MAY incorporate an edit by publishing a new PROPOSE that references the original (supersession).

#### WITHDRAW

Author withdraws a proposal.

```json
{
  "type": "WITHDRAW",
  "payload": {
    "proposal_id": "<message_id>",
    "reason": "<optional string>"
  }
}
```

Only the original author (verified by `from` key matching the proposal's `from` key) can withdraw. Nodes SHOULD stop counting votes for withdrawn proposals.

### Proposal Lifecycle

```
PROPOSE → open → voting → converging → ratified
                   ↓                       ↓
                rejected               adopted (per-node)
                   ↓
               WITHDRAW (by author, any stage)
```

There is no global state machine. Each node tracks its own view:

- **Open** — proposal exists, votes are accumulating
- **Converging** — vote weight exceeds local threshold (node-defined)
- **Ratified** — node considers the proposal accepted by the network
- **Rejected** — vote weight against exceeds local threshold
- **Adopted** — this specific node has applied the proposal locally

---

## 7. Votes

### VOTE Message

```json
{
  "type": "VOTE",
  "payload": {
    "proposal_id": "<message_id>",
    "stance": "endorse | reject",
    "reason": "<optional string>",
    "stake": <float — reputation staked on this vote>
  }
}
```

### Vote Rules

- One vote per node per proposal. A second vote from the same `from` key supersedes the first.
- Votes are weighted by the voter's reputation (see §8).
- Stake is optional. Staking reputation on a vote amplifies its weight but puts reputation at risk if the proposal is later found harmful.
- Nodes MAY vote on their own proposals (self-endorsement). The weight is the same — reputation is reputation.

### Local Evaluation

Each node evaluates proposals independently. There is no global "this passed" event. A node considers a proposal ratified when:

```
weighted_endorse / (weighted_endorse + weighted_reject) >= local_threshold
```

Where:
- `weighted_endorse` = sum of (voter_reputation × (1 + voter_stake)) for all endorse votes
- `weighted_reject` = sum of (voter_reputation × (1 + voter_stake)) for all reject votes
- `local_threshold` = configured per-node (suggested default: 0.67)

Nodes MAY use different thresholds for different proposal types (e.g., higher threshold for protocol changes).

---

## 8. Reputation

### Score

Each node maintains a reputation score for every peer it knows about.

| Field | Type | Description |
|---|---|---|
| `overall` | float | 0.0–1.0. Aggregate reputation. |
| `by_domain` | map | Domain-specific scores (e.g., `{"skills": 0.7, "config": 0.4}`) |
| `verification_count` | integer | How many times this peer has verified claims |
| `stake_at_risk` | float | Reputation currently staked on votes |

### Initial Score

New nodes start at **0.5**. This is enough to participate but not enough to dominate.

### Floor

Reputation cannot drop below **0.1**. Even badly-behaving nodes retain minimal participation rights. This prevents permanent exclusion and allows recovery.

### Earning Reputation

| Action | Reward | Notes |
|---|---|---|
| Proposal adopted by peers | +0.005 per adopting node | Capped at +0.05 per proposal |
| Claim verified true | +0.001 | Confirmation reward |
| Claim found false (by you) | +0.005 | Contradiction reward — finding problems is more valuable |
| First to find contradiction | +0.01 | First-finder bonus (2× contradiction base) |
| Vote with majority | +0.0005 | Small alignment signal |
| Storage verified via hash challenge | +0.001 per challenge passed | Future: proposed via protocol |
| Uptime (continuous availability) | +0.001 per day | Caps at 30 days accumulation |

### Losing Reputation

| Action | Penalty | Notes |
|---|---|---|
| Proposal with false claims | -0.003 per false claim | Contradiction penalty |
| Failed storage challenge | -0.01 | Future: proposed via protocol |
| Frivolous disputes | -0.02 | 20% of stake forfeited |
| Collusion detected | -0.05 | Anti-gaming penalty |
| Inactivity | -0.02 per month | Monthly decay after 30 days inactive |

### Velocity Limits

Reputation gains are capped to prevent gaming:

| Limit | Value |
|---|---|
| Maximum daily gain | 0.02 |
| Maximum weekly gain | 0.08 |
| Maximum monthly recovery | 0.03 |

### Reputation Propagation

Reputation is **locally computed** but **gossip-informed**.

When Node A evaluates Node B's reputation:

1. Start with A's direct observations of B (proposals, votes, claims)
2. Query peers for their assessment of B (`REPUTATION_GOSSIP` messages)
3. Weight each peer's assessment by A's trust in that peer (recursive)
4. Combine into a local score

```
reputation(B) = α × direct_observations(B) + (1-α) × Σ(trust(P) × reputation_P(B)) / Σ(trust(P))
```

Where `α` is the weight given to direct observation (suggested: 0.6) and the sum is over all peers P that have shared their assessment of B.

This is subjective — two nodes may have different reputation scores for the same peer. That's by design.

### Reputation Messages

#### REPUTATION_GOSSIP

Periodically shared with peers (suggested: every 15 minutes, share assessments of 10 random peers).

```json
{
  "type": "REPUTATION_GOSSIP",
  "payload": {
    "assessments": [
      {
        "node_id": "<hex_public_key>",
        "overall": <float>,
        "by_domain": { ... },
        "observation_count": <integer>,
        "last_observed": <unix_milliseconds>
      }
    ]
  }
}
```

#### REPUTATION_QUERY

Direct request to a peer for their assessment of a specific node.

```json
{
  "type": "REPUTATION_QUERY",
  "payload": {
    "node_id": "<hex_public_key>"
  }
}
```

Response follows the same schema as a single entry in `REPUTATION_GOSSIP`.

---

## 9. Sybil Resistance

### Verifiable Delay Function (VDF)

New nodes MUST compute a VDF proof before they can publish proposals or votes. This makes mass identity creation economically impractical.

**Parameters:**
- Algorithm: Iterated SHA-256 (v0; may be upgraded to a proper VDF via protocol proposal)
- Difficulty: 1,000,000 iterations (~30 seconds on commodity hardware)
- Input: The node's public key bytes
- Output: VDF proof (hash chain output + iteration count)

**Registration flow:**
1. Generate Ed25519 keypair
2. Compute VDF proof over public key bytes
3. Include proof in first `PEER_ANNOUNCE`
4. Peers verify the proof before accepting the node

Nodes that cannot present a valid VDF proof are ignored — their messages are not propagated and their votes are not counted.

### Peer Announce with VDF Proof

```json
{
  "type": "PEER_ANNOUNCE",
  "payload": {
    "addresses": ["<multiaddr>", ...],
    "capabilities": ["propose", "vote"],
    "version": 0,
    "uptime_seconds": 0,
    "vdf_proof": {
      "output": "<hex>",
      "proof": "<hex>",
      "input_data": "<hex — public key bytes>",
      "difficulty": 1000000,
      "duration_seconds": <float>
    }
  }
}
```

### Rate Limiting

Nodes SHOULD rate-limit new peer acceptance:
- Maximum 50 verifications per day
- Maximum 5 new peers accepted per hour
- VDF proofs older than 24 hours SHOULD be rejected (prevents pre-computation stockpiling)

---

## 10. Partition Detection

### Merkle Consistency

Nodes periodically compute a Merkle root over their active proposal set (all non-withdrawn, non-expired proposals, sorted by ID).

During sync, nodes exchange Merkle roots:

```json
{
  "type": "SYNC_RESPONSE",
  "payload": {
    "messages": [ ... ],
    "has_more": false,
    "checkpoint": "<merkle_root_hex>"
  }
}
```

If two nodes have different Merkle roots after a full sync, a **partition event** is recorded locally. The node SHOULD:

1. Log the divergence with severity
2. Attempt to sync with additional peers to determine which side has the correct view
3. Request specific missing proposals from the divergent peer

### Severity Classification

| Condition | Severity |
|---|---|
| < 5% proposal set difference | info |
| 5–20% difference | warning |
| > 20% difference | critical — possible extended partition |

Partition detection is informational. The protocol does not attempt automatic resolution — nodes sync, compare, and converge naturally through gossip.

---

## 11. Protocol Evolution

### Self-Hosting

v0 governs its own evolution. Protocol changes are proposals with:
- `eol` field set (when the previous version dies)
- Higher voting threshold (suggested: 0.80 for protocol changes vs. 0.67 for content)

### Version Negotiation

Every message carries `"version": 0`. When v1 is ratified, nodes that adopt it start sending `"version": 1`. During the grace period (between ratification and EOL), nodes MUST:

1. Accept messages with version N or N+1
2. Respond in the version the peer sent
3. Fall back to the lower version if negotiation fails

After EOL, nodes on version N stop accepting messages from version N-1 peers. Those peers are effectively dropped from the network.

### Upgrade Path

A protocol change proposal MUST include:
- The complete new specification (or a diff against the current spec)
- The EOL date for the current version
- A migration path: what nodes need to do to upgrade

The proposal IS the upgrade. Adopting the proposal means implementing the new spec.

### Constraints

- Changes MUST NOT cause silent misinterpretation between versions during the grace period
- Version negotiation MUST cleanly fail (no connection) rather than corrupt
- EOL timelines SHOULD reflect the scope of change (minor: 30 days, major: 90+ days)

---

## What's NOT in v0 (Proposed Through v0)

The following are explicitly out of scope for v0. Each should be proposed and ratified through the protocol when the network is ready:

- **Storage services** — encrypted shard hosting, hash challenges
- **Inference services** — offering compute to the network
- **Claim verification** — systematic verification of proposal claims
- **Formal consensus thresholds** — protocol-level quorum rules
- **Reputation staking on votes** — amplifying vote weight by risking reputation
- **Slashing** — stake forfeiture for proven bad behavior (50% for critical, 25% for high severity)
- **Dispute resolution** — formal process for challenging verification results
- **Calibration scoring** — Brier score tracking for prediction accuracy
- **Bounties** — rewards for finding contradictions in high-confidence claims
- **Group coordination** — multi-node working groups for complex proposals
- **Content delivery** — peer-to-peer artifact distribution beyond URL fetch

Each of these has existing implementation in Valence (the predecessor project) and can be ported as a proposal when the network is ready to adopt it.

---

## Reference Implementations

This spec is language-agnostic. Reference implementations live in sibling repositories:

- `valence-network-rs` — Rust (primary)
- Others as the community provides

### Conformance

A conformance test suite (TBD) will define message exchanges with expected outcomes. Any implementation that passes the test suite is compliant, regardless of language or internal architecture.

---

## Constants Summary

| Constant | Value | Context |
|---|---|---|
| Ed25519 key size | 32 bytes (private), 32 bytes (public), 64 bytes (signature) | §1 |
| Max message payload | 8 MiB | §2 |
| Inline content limit | 1 MiB | §6 |
| GossipSub topics | 3 (`/valence/proposals`, `/valence/votes`, `/valence/peers`) | §3 |
| Peer announce interval | 5 minutes | §4 |
| Peer expiry | 30 minutes without announce | §4 |
| Anti-fragmentation interval | 10 minutes | §4 |
| Dedup cache size | 100,000 entries (LRU) | §5 |
| Initial reputation | 0.5 | §8 |
| Reputation floor | 0.1 | §8 |
| Max daily reputation gain | 0.02 | §8 |
| Max weekly reputation gain | 0.08 | §8 |
| Monthly inactivity decay | 0.02 | §8 |
| Direct observation weight (α) | 0.6 | §8 |
| Reputation gossip interval | 15 minutes, 10 random peers | §8 |
| Default vote threshold | 0.67 | §7 |
| Protocol change vote threshold | 0.80 | §11 |
| VDF difficulty | 1,000,000 iterations | §9 |
| VDF target duration | ~30 seconds | §9 |
| VDF proof max age | 24 hours | §9 |
| Max new peers per hour | 5 | §9 |
