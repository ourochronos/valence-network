# v0 — Protocol Specification

v0 is the bootstrap protocol. It is the only version designed by hand — everything after is proposed and ratified by the network through v0's own mechanisms.

## Table of Contents

1. [Identity](#1-identity)
2. [Message Format](#2-message-format)
3. [Transport](#3-transport)
4. [Peer Discovery](#4-peer-discovery)
5. [Gossip](#5-gossip)
6. [Proposals](#6-proposals)
7. [Votes](#7-votes)
8. [Reputation](#8-reputation)
9. [Sybil Resistance](#9-sybil-resistance)
10. [Anti-Gaming](#10-anti-gaming)
11. [Partition Detection](#11-partition-detection)
12. [Protocol Evolution](#12-protocol-evolution)
13. [Error Handling](#13-error-handling)
14. [Open Questions](#14-open-questions)

---

## 1. Identity

A node is an Ed25519 keypair.

- **Private key:** 32 bytes, Ed25519. Never transmitted.
- **Public key:** 32 bytes, Ed25519. Serves as the node's identity.
- **Node ID:** The hex-encoded public key. This is the canonical identifier.

All messages are signed by the sender's private key. All signatures are verified against the sender's public key.

### Key Operations

| Operation | Algorithm | Input | Output |
|---|---|---|---|
| Sign | Ed25519 | message bytes + private key | 64-byte signature |
| Verify | Ed25519 | message bytes + signature + public key | boolean |

### Key Rotation

A node MAY rotate its keypair by publishing a `KEY_ROTATE` message signed by **both** the old and new keys:

```json
{
  "type": "KEY_ROTATE",
  "payload": {
    "old_key": "<hex_old_public_key>",
    "new_key": "<hex_new_public_key>",
    "new_key_signature": "<hex — payload signed by new private key>"
  }
}
```

The envelope itself is signed by the old key (standard signing). The `new_key_signature` field contains the same payload signed by the new private key. Nodes that verify both signatures MUST update their peer table to associate the old key's reputation with the new key.

After rotation, messages signed by the old key MUST be rejected (after a 24-hour grace period to allow propagation).

### DID Representation (Optional)

Nodes MAY represent their identity as a DID for interoperability:

```
did:valence:<hex-encoded-public-key>
```

The protocol does not require DIDs — the raw public key is sufficient.

---

## 2. Message Format

Every message is a signed JSON envelope.

### Canonicalization

All JSON serialization for signing and hashing MUST follow **RFC 8785 (JSON Canonicalization Scheme — JCS)**:

- Object keys sorted lexicographically by Unicode code point
- No whitespace between tokens
- Numbers serialized per ECMAScript rules (no trailing zeros, no leading plus, etc.)
- Unicode: NFC normalization
- Null values included (not omitted)
- Recursively applied to nested objects

Implementations MUST produce identical byte output for identical logical structures. Failure to canonicalize correctly will cause signature verification failures across implementations.

### Wire Format

**Stream protocols (point-to-point):** Length-prefixed JSON.

```
+-------------------+-----------------------------+
| 4 bytes (BE u32)  |  JSON payload (UTF-8)       |
| = payload length  |                             |
+-------------------+-----------------------------+
```

Maximum payload size: 8 MiB. Messages exceeding this MUST be rejected.

**GossipSub (broadcast):** Plain UTF-8 JSON. GossipSub handles message boundaries.

### Envelope Schema

```json
{
  "version": 0,
  "type": "<message_type>",
  "id": "<sha256_hex_of_signing_body>",
  "from": "<hex_public_key>",
  "timestamp": <unix_milliseconds>,
  "payload": { ... },
  "signature": "<hex_ed25519_signature>"
}
```

| Field | Type | Description |
|---|---|---|
| `version` | integer | Protocol version. MUST be `0` for this spec. |
| `type` | string | Message type. |
| `id` | string | SHA-256 hex digest of the **signing body** (see below). Content address. |
| `from` | string | Hex-encoded Ed25519 public key of the sender. |
| `timestamp` | integer | Unix time in milliseconds when the message was created. |
| `payload` | object | Type-specific payload. |
| `signature` | string | Hex-encoded Ed25519 signature over the signing body bytes. |

### Signing Body

The signature covers the JCS-canonicalized bytes of:

```json
{
  "from": "<from>",
  "payload": <payload>,
  "timestamp": <timestamp>,
  "type": "<type>",
  "version": <version>
}
```

(Keys in lexicographic order per JCS.)

### Content Addressing

The `id` field is the SHA-256 hex digest of the signing body bytes. Because `id` includes `from` and `timestamp`, two different nodes publishing identical payloads produce different IDs. Messages are deduplicated by `id`.

### Timestamp Validation

Nodes MUST reject messages with timestamps more than **5 minutes** from the node's local time (past or future). This requires loose clock synchronization (NTP). Messages that fail timestamp validation MUST NOT be propagated.

---

## 3. Transport

v0 uses libp2p as the transport layer.

### Stream Protocols (Point-to-Point)

| Protocol ID | Purpose |
|---|---|
| `/valence/sync/1.0.0` | Pull-based synchronization and peer exchange |
| `/valence/auth/1.0.0` | Authentication handshake (see below) |

### Authentication Handshake

When two nodes first connect, they exchange an auth challenge over `/valence/auth/1.0.0`:

1. **Initiator** sends `AUTH_CHALLENGE` with a random 32-byte nonce
2. **Responder** signs the nonce with their private key and returns `AUTH_RESPONSE` with signature + public key + VDF proof
3. **Initiator** verifies signature, VDF proof, and adds peer to table

```json
{"type": "AUTH_CHALLENGE", "payload": {"nonce": "<hex_32_random_bytes>"}}
{"type": "AUTH_RESPONSE", "payload": {"signature": "<hex>", "public_key": "<hex>", "vdf_proof": { ... }}}
```

Nodes MUST complete auth before accepting any other messages from a peer.

### GossipSub Topics (Broadcast)

| Topic | Purpose |
|---|---|
| `/valence/proposals` | New proposals, edits, withdrawals |
| `/valence/votes` | Vote broadcasts |
| `/valence/peers` | Peer discovery announcements |

### NAT Traversal

Nodes SHOULD support libp2p circuit relay v2 for NAT traversal. Nodes with public addresses SHOULD act as relay nodes.

### Connection Security

All connections use libp2p's Noise protocol for encryption and authentication.

---

## 4. Peer Discovery

### Bootstrap

A new node starts with at least one known peer address (a bootstrap node). Bootstrap nodes are regular nodes that happen to be well-known.

Reference implementations MUST include a default bootstrap list. Nodes MAY configure additional or alternative bootstrap nodes.

### Fallback Discovery

When GossipSub-based discovery is unavailable (no connected peers), nodes SHOULD attempt:

1. **mDNS** — discover peers on the local network (for development and LAN deployments)
2. **DNS TXT records** — query a well-known domain for bootstrap peer multiaddrs (e.g., `_valence-bootstrap._tcp.valence.network`)

### Peer Exchange via Sync Protocol

The `/valence/sync/1.0.0` protocol MUST support direct peer list exchange, independent of GossipSub:

```json
{"type": "PEER_LIST_REQUEST", "payload": {"limit": 50}}
{"type": "PEER_LIST_RESPONSE", "payload": {"peers": [{"node_id": "<hex>", "addresses": ["<multiaddr>"]}]}}
```

This enables a freshly bootstrapped node to discover peers before joining the GossipSub mesh.

### Peer Announcements

Nodes announce on the `/valence/peers` GossipSub topic:

```json
{
  "type": "PEER_ANNOUNCE",
  "payload": {
    "addresses": ["<multiaddr>", ...],
    "capabilities": ["propose", "vote", "store"],
    "version": 0,
    "uptime_seconds": <integer>,
    "vdf_proof": { ... }
  }
}
```

Nodes SHOULD announce every **5 minutes**. Nodes SHOULD prune peers that haven't announced in **30 minutes**.

### Anti-Fragmentation

Nodes MUST periodically connect to random peers outside their immediate neighborhood (suggested: every **10 minutes**). This prevents the network from clustering into disconnected subgraphs.

### ASN Diversity

Nodes SHOULD track the Autonomous System Number (ASN) distribution of their peers and enforce:

- No single ASN > 25% of connections
- Minimum 4 distinct ASNs (when enough peers are available)

This provides eclipse resistance — an attacker controlling one network segment cannot dominate a node's peer set.

---

## 5. Gossip

### Push

When a node creates or receives a new message, it publishes to the appropriate GossipSub topic.

### Pull (Sync)

Nodes periodically request missed messages from peers via `/valence/sync/1.0.0`:

**Sync Request:**

```json
{
  "type": "SYNC_REQUEST",
  "payload": {
    "since_timestamp": <unix_milliseconds>,
    "since_id": "<message_id — for cursor stability>",
    "types": ["PROPOSE", "VOTE"],
    "limit": 100
  }
}
```

**Sync Response:**

```json
{
  "type": "SYNC_RESPONSE",
  "payload": {
    "messages": [ ... ],
    "has_more": true,
    "next_timestamp": <unix_milliseconds>,
    "next_id": "<message_id>",
    "checkpoint": "<merkle_root_hex>"
  }
}
```

Pagination uses a `(timestamp, id)` cursor to handle multiple messages at the same millisecond deterministically.

### Deduplication

Nodes maintain a set of seen message IDs. A message MUST NOT be re-propagated if its `id` has already been seen. Implementations SHOULD use a bounded LRU cache (suggested: **100,000 entries**).

**Time-based rejection:** Messages with timestamps older than **24 hours** MUST be rejected regardless of dedup cache state. This prevents replay attacks via cache eviction flooding.

---

## 6. Proposals

### Message Types

#### REQUEST

A broadcast need. "I need something."

```json
{
  "type": "REQUEST",
  "payload": {
    "title": "<string>",
    "body": "<string — markdown>",
    "tags": ["<string>", ...],
    "expires": <unix_milliseconds | null>
  }
}
```

#### PROPOSE

A proposed solution. May reference a request, or stand alone.

```json
{
  "type": "PROPOSE",
  "payload": {
    "title": "<string>",
    "body": "<string — markdown description>",
    "content_hash": "<sha256_hex>",
    "content_type": "<mime_type>",
    "content_size": <bytes>,
    "content_url": "<optional — where to fetch the artifact>",
    "content_inline": "<optional — base64, max 1 MiB>",
    "request_id": "<message_id | null>",
    "supersedes": "<message_id | null — previous proposal this replaces>",
    "claims": [
      {
        "statement": "<human-readable claim>",
        "verifiable": <boolean>,
        "evidence": "<optional — URL or description>"
      }
    ],
    "eol": <unix_milliseconds | null>,
    "voting_deadline": <unix_milliseconds>
  }
}
```

**Content delivery:** Small artifacts (< 1 MiB) MAY be inlined as base64 in `content_inline`. Larger artifacts are referenced by `content_hash` and distributed using erasure-coded shards (see below). The hash ensures integrity regardless of source.

**Claims:** Verifiable assertions about the proposal. Signal for evaluation.

**EOL:** Only for protocol change proposals. When the previous protocol version dies.

**Voting deadline:** Required. Proposals MUST specify a deadline (suggested default: 14 days, max: 90 days). Votes received after the deadline MUST NOT be counted.

#### WITHDRAW

Author withdraws a proposal.

```json
{
  "type": "WITHDRAW",
  "payload": {
    "proposal_id": "<message_id>",
    "reason": "<optional string>"
  }
}
```

Only the original author (verified by `from` key) can withdraw. Nodes MUST stop counting new votes for withdrawn proposals. Nodes that have already locally adopted a proposal are not affected by a later withdrawal.

### Proposal Lifecycle

There is no global state machine. Each node tracks its own view:

- **Open** — proposal exists, votes accumulating, deadline not reached
- **Converging** — weighted endorsement exceeds local threshold
- **Ratified** — node considers the proposal accepted by the network
- **Rejected** — weighted rejection exceeds local threshold, or deadline passed without ratification
- **Adopted** — this specific node has applied the proposal locally and broadcast an ADOPT message
- **Expired** — voting deadline passed
- **Withdrawn** — author withdrew

### Adoption

When a node locally adopts a proposal, it broadcasts an `ADOPT` message:

```json
{
  "type": "ADOPT",
  "payload": {
    "proposal_id": "<message_id>",
    "success": <boolean>,
    "notes": "<optional string>"
  }
}
```

Adoption messages serve as usage attestations — they provide concrete signal that a proposal was applied and whether it worked. They feed into reputation (§8) and help other nodes evaluate proposals.

Nodes MUST NOT fabricate adoption messages. The `success` field allows nodes to report that they adopted something and it broke — this is valuable negative signal.

### Supersession

Edits to proposals are expressed as new proposals with `supersedes` set to the original proposal's ID. This is simpler than a separate edit mechanism — an edit is just a new proposal that references what it improves. The community votes on the new proposal independently.

### Content Delivery

Large artifacts (> 1 MiB) are distributed using erasure-coded shards across willing peers.

**Erasure coding levels:**

| Level | Data Shards | Parity Shards | Description |
|---|---|---|---|
| minimal | 3 | 2 | 3-of-5 — any 3 shards reconstruct the artifact |
| standard | 5 | 3 | 5-of-8 — default for proposals |
| resilient | 8 | 4 | 8-of-12 — for high-value artifacts |

**Flow:**
1. Proposer erasure-codes the artifact into shards
2. Proposer distributes shards to willing peers (nodes with `"store"` capability)
3. Each shard is content-addressed by its own hash
4. The proposal's `content_hash` is the hash of the original artifact
5. Nodes wanting the artifact request shards from peers, reconstruct with any `data_shards` count of shards

**Shard metadata** is included in the proposal:

```json
"content_shards": {
  "coding": "standard",
  "data_shards": 5,
  "parity_shards": 3,
  "shard_hashes": ["<hex>", ...],
  "shard_size": <bytes>
}
```

Nodes storing shards earn reputation via storage challenges (§8). `content_url` remains as a fallback for HTTP-hosted artifacts.

---

## 7. Votes

### VOTE Message

```json
{
  "type": "VOTE",
  "payload": {
    "proposal_id": "<message_id>",
    "stance": "endorse | reject",
    "reason": "<optional string>"
  }
}
```

### Vote Rules

- One vote per node per proposal. A second vote from the same `from` key supersedes the first.
- Votes are weighted by the voter's reputation (see §8).
- Nodes MAY vote on their own proposals. The weight is the same.
- Votes received after the proposal's `voting_deadline` MUST NOT be counted.

### Local Evaluation

Each node evaluates proposals independently. Nodes MUST re-evaluate proposal status whenever new votes (including superseding votes) are received. There is no global "this passed" event.

A node considers a proposal ratified when **both**:

1. **Quorum met:** At least `max(3, floor(sqrt(known_peers)))` distinct nodes have voted
2. **Threshold met:**
   ```
   weighted_endorse / (weighted_endorse + weighted_reject) >= local_threshold
   ```

Where:
- `weighted_endorse` = sum of `voter_reputation` for all endorse votes
- `weighted_reject` = sum of `voter_reputation` for all reject votes
- `local_threshold` = configured per-node (suggested default: **0.67**)
- Nodes SHOULD use a higher threshold for protocol change proposals (suggested: **0.80**)

---

## 8. Reputation

### Score

Each node maintains a reputation score for every peer it knows about.

| Field | Type | Description |
|---|---|---|
| `overall` | float | 0.0–1.0. Aggregate reputation. |
| `by_domain` | map | Domain-specific scores (e.g., `{"skills": 0.7, "config": 0.4}`) |
| `verification_count` | integer | How many times this peer has verified claims |
| `stake_at_risk` | float | Reputation currently at risk from disputed claims |

### Initial Score

New nodes start at **0.5**.

### Floor

Reputation cannot drop below **0.1**. This prevents permanent exclusion and allows recovery.

### Earning Reputation

| Action | Reward | Notes |
|---|---|---|
| Proposal adopted by peers | +0.005 per ADOPT message received | Capped at +0.05 per proposal |
| Claim verified true | +0.001 | Confirmation reward |
| Claim found false (by you) | +0.005 | Contradiction reward |
| First to find contradiction | +0.01 | First-finder bonus |
| Storage verified via hash challenge | +0.001 per challenge | Future: proposed via protocol |
| Uptime (continuous availability) | +0.001 per day | Caps at 30 days accumulation |

### Losing Reputation

| Action | Penalty | Notes |
|---|---|---|
| Proposal with false claims | -0.003 per false claim | Contradiction penalty |
| Failed storage challenge | -0.01 | Future |
| Collusion detected | -0.05 | See §10 |
| Inconsistent reputation reporting | -0.02 | See below |
| Inactivity | -0.02 per month | After 30 days inactive |

### Velocity Limits

| Limit | Value |
|---|---|
| Maximum daily gain | 0.02 |
| Maximum weekly gain | 0.08 |
| Maximum monthly recovery | 0.03 |

### Reputation Propagation

Reputation is **locally computed** and **gossip-informed**.

When Node A evaluates Node B's reputation:

1. Start with A's direct observations of B
2. Query peers for their signed assessments of B
3. Weight each peer's assessment by A's trust in that peer
4. Combine:

```
reputation(B) = α × direct_observations(B) + (1-α) × Σ(trust(P) × assessment_P(B)) / Σ(trust(P))
```

Where:
- `α` = **0.6** (weight for direct observation)
- Sum is over peers P that have shared signed assessments of B
- `trust(P)` = A's direct reputation score for P (NOT recursive — to avoid circular dependency)

Trust is **one level deep**: you trust your peers based on your direct experience with them, and their assessments influence your view of nodes you haven't directly observed. No recursive resolution needed.

### Signed Reputation Attestations

Reputation gossip MUST be signed. Each assessment is attributable.

```json
{
  "type": "REPUTATION_GOSSIP",
  "payload": {
    "assessments": [
      {
        "node_id": "<hex_public_key>",
        "overall": <float>,
        "by_domain": { ... },
        "observation_count": <integer>,
        "last_observed": <unix_milliseconds>
      }
    ]
  }
}
```

Because assessments are signed by the sender, **inconsistent reporting is detectable**. If Node A tells Node B that Node C has score 0.1, and tells Node D that Node C has score 0.9, and B and D compare notes, A's inconsistency is provable. Nodes detecting inconsistent attestations SHOULD penalize the reporter (-0.02).

Nodes SHOULD share reputation gossip every **15 minutes**, covering **10 random peers** per message.

---

## 9. Sybil Resistance

### Verifiable Delay Function (VDF)

New nodes MUST compute a VDF proof before participating. This makes mass identity creation expensive.

**Parameters:**
- Algorithm: Iterated SHA-256 (v0). Acknowledged limitation: verification requires recomputation. A proper VDF (Wesolowski/Pietrzak) with fast verification can be proposed via the protocol.
- Difficulty: **1,000,000 iterations** (~30 seconds on commodity hardware)
- Input: The node's public key bytes
- Output: VDF proof (hash chain output + intermediate checkpoints)

**Intermediate checkpoints:** To reduce verification cost, the proof includes hashes at every 100,000th iteration (10 checkpoints). Verifiers can spot-check random checkpoints rather than recomputing the full chain. This reduces verification to ~3 seconds (one segment) with probabilistic confidence.

### Registration Flow

1. Generate Ed25519 keypair
2. Compute VDF proof over public key bytes
3. Include proof in auth handshake (§3)
4. Peers verify the proof (spot-check) before accepting the node

### VDF Proof Schema

```json
{
  "output": "<hex>",
  "input_data": "<hex — public key bytes>",
  "difficulty": 1000000,
  "checkpoints": [
    {"iteration": 100000, "hash": "<hex>"},
    {"iteration": 200000, "hash": "<hex>"},
    ...
  ]
}
```

### Rate Limiting

- Maximum 50 VDF verifications per day
- Maximum 5 new peers accepted per hour
- VDF proofs with `input_data` that doesn't match the sender's public key MUST be rejected
- VDF proofs MUST be fresh — verified during the auth handshake, not pre-shared

---

## 10. Anti-Gaming

### Collusion Detection

Nodes SHOULD analyze voting patterns for collusion indicators:

1. **Voting correlation:** Flag groups of 3+ nodes with >95% vote correlation over 20+ proposals
2. **Registration timing:** Flag 3+ nodes whose VDF proofs were computed within a 24-hour window
3. **ASN clustering:** Flag when >25% of active voters share an ASN

Detection is local — each node runs its own analysis. When collusion indicators are found:

- **WARNING severity:** Log, reduce trust in flagged nodes
- **HIGH severity:** Reduce reputation of flagged nodes by 0.05
- **Nodes MAY share collusion alerts** via proposals ("I've detected collusion, here's the evidence, should we act?")

### Tenure Limits

Nodes whose proposals have been ratified in 4+ consecutive voting cycles receive a tenure penalty:

- **10% reduction** in vote weight per cycle after the 4th
- This prevents entrenchment — early participants can't permanently dominate

### Diversity Scoring

When evaluating proposals, nodes MAY weight votes higher when they come from a diverse set of voters (measured by ASN diversity, federation membership, registration age).

---

## 11. Partition Detection

### Merkle Consistency

Nodes periodically compute a Merkle root over their active proposal set.

**Tree construction:**
- **Leaves:** SHA-256 hash of each active (non-withdrawn, non-expired) proposal's `id`
- **Ordering:** Leaves sorted lexicographically by `id`
- **Structure:** Binary Merkle tree, left-biased for odd leaf counts (last leaf promoted)
- **Hash function:** SHA-256 for internal nodes: `SHA256(left_child || right_child)`

During sync, nodes exchange Merkle roots in `SYNC_RESPONSE`. Divergent roots trigger a partition event.

### Severity Classification

| Condition | Severity |
|---|---|
| < 5% proposal set difference | info |
| 5–20% difference | warning |
| > 20% difference | critical |

### Proposal Retention

The active proposal set MUST be bounded to prevent unbounded growth. Retention policy:

- **Expired proposals** (past `voting_deadline` without ratification): archived after **7 days**
- **Withdrawn proposals:** archived after **7 days**
- **Rejected proposals** (weighted rejection exceeded threshold): archived after **30 days**
- **Ratified proposals:** archived after **180 days** (6 months)
- **Protocol change proposals:** never auto-archived (permanent record)

Archived proposals are removed from the active set and the Merkle tree. Nodes MAY retain archived proposals locally for historical reference but MUST NOT include them in Merkle root computation or sync responses (unless specifically requested).

Archival runs periodically (suggested: daily) in configurable batch sizes (suggested: 1000 per run).

### Partition Merge

When partitions heal and nodes discover proposals they missed:

1. Sync all missing proposals and votes from both sides
2. Re-evaluate all proposals with the complete vote set
3. If contradictory proposals were ratified in isolation, both exist — nodes vote on which to keep, or both coexist

Partition resolution is organic. No automatic invalidation.

---

## 12. Protocol Evolution

### Self-Hosting

v0 governs its own evolution. Protocol changes are proposals with:
- `eol` field set (when the previous version dies)
- Higher voting threshold (suggested: 0.80)
- Higher quorum (suggested: `max(5, floor(sqrt(known_peers) * 1.5))`)

### Version Negotiation

Every message carries `"version": 0`. When v1 is ratified, nodes that adopt it start sending `"version": 1`. During the grace period:

1. Nodes MUST accept messages with version N or N+1
2. Nodes MUST respond in the version the peer sent
3. Nodes MUST cleanly reject (not silently corrupt) messages from unrecognized versions

After EOL, nodes on version N stop accepting messages from version N-1 peers.

### Upgrade Path

A protocol change proposal MUST include:
- The complete new specification (or a diff against the current spec)
- The EOL date for the current version
- A migration path

### EOL Timelines

Set by the community as part of the proposal:
- **Minor changes:** 30 days minimum
- **Major changes:** 90+ days minimum

### Constraints

- Changes MUST NOT cause silent misinterpretation between versions during grace period
- Version negotiation MUST cleanly fail rather than corrupt
- The network can evolve into anything it decides — if it decides to suck, that sucks

---

## 13. Error Handling

### Malformed Messages

Messages that fail parsing, signature verification, or timestamp validation MUST be silently dropped. Nodes MUST NOT propagate invalid messages.

### Unknown Message Types

Messages with unrecognized `type` values MUST be propagated but not processed. This enables forward compatibility — a v0 node can relay v0.1 messages it doesn't understand.

### Unknown Fields

Messages with extra fields beyond the schema MUST be accepted (ignore unknown fields). Implementations MUST NOT reject messages with additional fields. This enables extension without protocol version bumps.

### Missing Proposals

When a node receives a VOTE for a proposal it hasn't seen:

1. Store the vote
2. Request the missing proposal from the vote's sender via sync
3. Apply the vote once the proposal arrives

Votes are valid even if they arrive before their proposal (due to gossip ordering).

### Unresponsive Peers

Nodes SHOULD implement exponential backoff for unresponsive peers, with a maximum retry interval of 10 minutes. After 30 minutes without response, the peer SHOULD be pruned from the active peer table (but not forgotten — it can re-announce).

---

## 14. Open Questions

These are acknowledged gaps in v0. They may be addressed by protocol proposals, by operational experience, or by future spec revisions before v0 is finalized.

### Large-Scale Reputation Gossip

At 10,000 nodes, reputation gossip every 15 minutes at 10 assessments each produces ~111 messages/second. Mitigations to consider:
- Adaptive gossip frequency (less frequent as network grows)
- Only gossip about nodes whose reputation changed
- Hierarchical gossip (cluster-level summaries)

This is a scaling problem that doesn't affect bootstrap. Can be addressed by protocol proposal when the network reaches a size where it matters.

### VDF Hardware Heterogeneity

A 30-second VDF on commodity hardware is 3 seconds on a fast server. The difficulty parameter doesn't equalize across hardware. This means well-resourced attackers face a lower cost per identity. Accepted trade-off for v0: it raises the floor, not the ceiling. A proper VDF (Wesolowski/Pietrzak) with verifiable timing can be proposed via the protocol.

### Blacklisting / Banning

v0 has no mechanism to permanently exclude a node. A node with reputation at floor (0.1) can still participate, just with minimal weight. This is intentional — permanent exclusion is antithetical to the protocol's values. Nodes can locally block specific peers at the implementation level. The network can propose a formal ban mechanism if it decides it needs one.

### Conformance Test Suite

Not yet written. A set of message exchanges with expected outcomes that any implementation must pass. Critical for interoperability. Should be published alongside the first reference implementation.

---

## Constants Summary

| Constant | Value | Context |
|---|---|---|
| Ed25519 key size | 32 bytes (private), 32 bytes (public), 64 bytes (signature) | §1 |
| Key rotation grace period | 24 hours | §1 |
| Canonicalization | RFC 8785 (JCS) | §2 |
| Max message payload | 8 MiB | §2 |
| Timestamp tolerance | ±5 minutes | §2 |
| Inline content limit | 1 MiB | §6 |
| GossipSub topics | 3 | §3 |
| Peer announce interval | 5 minutes | §4 |
| Peer expiry | 30 minutes | §4 |
| Anti-fragmentation interval | 10 minutes | §4 |
| Max ASN fraction | 25% | §4 |
| Min distinct ASNs | 4 | §4 |
| Dedup cache size | 100,000 entries (LRU) | §5 |
| Message max age | 24 hours | §5 |
| Voting deadline default | 14 days | §6 |
| Voting deadline max | 90 days | §6 |
| Minimum quorum | max(3, floor(sqrt(known_peers))) | §7 |
| Default vote threshold | 0.67 | §7 |
| Protocol change threshold | 0.80 | §7, §12 |
| Initial reputation | 0.5 | §8 |
| Reputation floor | 0.1 | §8 |
| Max daily reputation gain | 0.02 | §8 |
| Max weekly reputation gain | 0.08 | §8 |
| Monthly inactivity decay | 0.02 | §8 |
| Max monthly recovery | 0.03 | §8 |
| Direct observation weight (α) | 0.6 | §8 |
| Reputation gossip interval | 15 minutes | §8 |
| Reputation gossip batch | 10 random peers | §8 |
| Inconsistent reporting penalty | -0.02 | §8 |
| VDF difficulty | 1,000,000 iterations | §9 |
| VDF checkpoints | every 100,000 iterations | §9 |
| VDF max verifications/day | 50 | §9 |
| Max new peers/hour | 5 | §9 |
| Vote correlation threshold | 95% over 20+ proposals | §10 |
| Tenure penalty onset | 4 consecutive cycles | §10 |
| Tenure penalty factor | 0.9× per cycle | §10 |
| Collusion penalty | -0.05 | §10 |
| Protocol change quorum | max(5, floor(sqrt(known_peers) × 1.5)) | §12 |
| Minor change EOL minimum | 30 days | §12 |
| Major change EOL minimum | 90 days | §12 |
| Expired proposal archive | 7 days | §6 |
| Withdrawn proposal archive | 7 days | §6 |
| Rejected proposal archive | 30 days | §6 |
| Ratified proposal archive | 180 days | §6 |
| Archival batch size | 1,000 | §6 |
| Default erasure coding | standard (5-of-8) | §6 |
| Peer backoff maximum | 10 minutes | §13 |
